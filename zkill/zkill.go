package zkill

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"sync"

	"github.com/vivace-io/evelib/util"
)

const (
	DefaultAddress = "https://zkillboard.com/api"
)

// Options holds the configuration for the package Client.
type Options struct {
	// UserAgent is the passed to ZKillboard in the User-Agent header of each
	// request and should generally contain an e-mail address and name. While it
	// is not required by this library to set it, it gives the ZKillboard
	// maintainers a way to contact the developer should they have any questions
	// or concerns about the developer's usage.
	UserAgent string
	// RootAddress is the ZKillboard API root URI, without the trailing slash. An
	// empty value will cause the client to default to the official ZKillboard API
	// root address. So this value only needs to be set if using a proxy or
	// custom instance of the ZKillboard application.
	RootAddress string
	// DisableTLS will disable TLS checks on HTTP calls if true, otherwise the
	// client will always check TLS for every call. Disabling TLS is NOT
	// recommended except in limited use cases, such CI testing in environments
	// that may not necissarily have certificate authorities installed or
	// referenced.
	DisableTLS bool
	// RateLimit is the maximum rate per second that calls may be made. The
	// official limit is 10, but the client will accept larger values. Any value
	// zero or below will result in an error being returned.
	RateLimit int
	// RateBurst is the maximum burst requests that may be made. The official
	// limit is 400, but the Client will accept larger values. Any value zero
	// or below will result in an error being returned.
	RateBurst int
	// MaxConn is the maximum number of concurrent connections to CREST that may
	// exist at any given time. The official limit is 5, but the client will
	// accept larger values. Any value zero or below will result in an error
	// being returned.
	MaxConn int
}

// DefaultOptions returns a new instance of the default options for the package
// client. The request rate and maximum connections are set to the official
// maximums, and the root API address is set as the offical zKillboard API
// address.
func DefaultOptions() *Options {
	return &Options{
		RootAddress: DefaultAddress,
		DisableTLS:  false,
		RateLimit:   10,
		RateBurst:   10,
		MaxConn:     5,
	}
}

// ValidateOptions returns an error if the options passed are fatally invalid.
func ValidateOptions(opts *Options) error {
	if opts.MaxConn <= 0 {
		return fmt.Errorf("Options.MaxConn was expected to be greater than zero but was %v", opts.MaxConn)
	}
	if opts.RateLimit <= 0 {
		return fmt.Errorf("Options.RateLimit was expected to be greater than zero but was %v", opts.RateLimit)
	}
	if opts.RateLimit > 10 {
		return fmt.Errorf("Options.RateLimit was expected to be 10 at most but was %v", opts.RateLimit)
	}
	if opts.RateBurst <= 0 {
		return fmt.Errorf("Options.RateBurst was expected to be greater than zero but was %v", opts.RateBurst)
	}
	if opts.RootAddress == "" {
		opts.RootAddress = DefaultAddress
	}
	return nil
}

// Client is a client to access zKillboard's API.
type Client struct {
	locker    *sync.RWMutex
	opts      *Options
	limiter   *util.Limiter
	webClient *http.Client
}

// NewClient returns a new API client. If the options passed are nil, it uses
// the options generated by DefaultOptions. For misconfiguration errors, returns
// nil for client and an error.
func NewClient(opts *Options) (client *Client, err error) {
	if opts == nil {
		opts = DefaultOptions()
	}
	if err = ValidateOptions(opts); err != nil {
		return
	}
	client = &Client{
		locker: new(sync.RWMutex),
		opts:   opts,
	}
	client.webClient = &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: opts.DisableTLS},
		},
	}
	// Error checking util.NewLimiter is redundant here, as ValidateOptions covers
	// any error that may be returned, so ignore the error.
	client.limiter, _ = util.NewLimiter(opts.RateLimit, opts.RateBurst, opts.MaxConn)
	return
}

func (client *Client) fetch(path string, model interface{}) (err error) {
	// Wait for connection to proceed before anything else. Function waits now
	// rather than immediately prior to executing request to conserve resources
	// in more intensive applications.
	client.limiter.Connect()
	defer client.limiter.Disconnect()
	// Gain read lock (holds no importance as of yet but will in the near future)
	client.locker.RLock()
	defer client.locker.RUnlock()
	var request *http.Request
	request, err = http.NewRequest("GET", client.opts.RootAddress+path, nil)
	if err != nil {
		return err
	}
	if client.opts.UserAgent != "" {
		request.Header.Add("User-Agent", client.opts.UserAgent)
	}
	var rawresp *http.Response
	rawresp, err = client.webClient.Do(request)
	if err != nil {
		return err
	}
	defer rawresp.Body.Close()
	var body []byte
	body, err = ioutil.ReadAll(rawresp.Body)
	if err != nil {
		return err
	}
	err = json.Unmarshal(body, &model)
	return err
}
