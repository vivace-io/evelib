package crest

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"sync"

	"github.com/vivace-io/evelib/util"
)

const (
	TranquilityURI = "https://crest-tq.eveonline.com/"
	SingularityURI = "https://api-sisi.testeveonline.com/"
	CRESTVersion   = "application/vnd.ccp.eve.Api-v2+json"
)

// Options holds the configuration for the package Client.
type Options struct {
	// UserAgent is the passed to CREST in the User-Agent header of each request
	// and should generally contain an e-mail address and name. While it is not
	// required, it gives CCP a way to contact the developer should they have any
	// questions or concerns about the developer's usage.
	UserAgent string
	// RootAddress is the CREST API root URI, without the trailing slash. An empty
	// value will cause the client to default to the official Tranquility root URI.
	RootAddress string
	// DisableTLS will disable TLS checks on HTTP calls if true, otherwise the
	// client will always check TLS for every call. Disabling TLS is NOT
	// recommended except in limited use cases, such CI testing in environments
	// that may not necissarily have certificate authorities installed or
	// referenced.
	DisableTLS bool
	// RateLimit is the maximum rate per second that calls may be made. the
	// official limit is 150, but the client will accept larger values. Any value
	// zero or below zero will result in an error being returned.
	RateLimit int
	// RateBurst is the maximum burst requests that may be made. The official
	// limit is 400, but the Client will accept larger values. Any value zero
	// or below will result in an error being returned.
	RateBurst int
	// MaxConn is the maximum number of concurrent connections to CREST that may
	// exist at any given time. The official limit is 5, but the client will
	// accept larger values. Any value zero or below will result in an error
	// being returned.
	MaxConn int
}

// DefaultOptions returns a new instance of the default options for the package
// client. The request rate and maximum connections are set to the official
// maximums, and the root API address is set as the offical Tranquility.
func DefaultOptions() *Options {
	return &Options{
		RootAddress: TranquilityURI,
		DisableTLS:  false,
		RateLimit:   150,
		RateBurst:   400,
		MaxConn:     5,
	}
}

// ValidateOptions returns an error if the options passed are fatally invalid.
func ValidateOptions(opts *Options) error {
	if opts.MaxConn <= 0 {
		return fmt.Errorf("Options.MaxConn was expected to be greater than zero but was %v", opts.MaxConn)
	}
	if opts.RateLimit <= 0 {
		return fmt.Errorf("Options.RateLimit was expected to be greater than zero but was %v", opts.RateLimit)
	}
	if opts.RateBurst <= 0 {
		return fmt.Errorf("Options.RateBurst was expected to be greater than zero but was %v", opts.RateBurst)
	}
	if opts.RootAddress == "" {
		opts.RootAddress = TranquilityURI
	}
	return nil
}

// Client to EVE Online's CREST API.
type Client struct {
	locker  *sync.RWMutex
	opts    *Options
	limiter *util.Limiter
}

// NewClient returns a new API client. If the options passed are nil, it uses
// the options generated by DefaultOptions. For misconfiguration errors, returns
// nil for client and an error.
func NewClient(opts *Options) (client *Client, err error) {
	if opts == nil {
		opts = DefaultOptions()
	}
	if err = ValidateOptions(opts); err != nil {
		return
	}
	client = &Client{
		locker: new(sync.RWMutex),
		opts:   opts,
	}
	// Error checking util.NewLimiter is redundant here, as ValidateOptions covers
	// any error that may be returned, so ignore the error.
	client.limiter, _ = util.NewLimiter(opts.RateLimit, opts.RateBurst, opts.MaxConn)
	return
}

func (c *Client) get(path string, model interface{}) (err error) {
	// Wait for connection to proceed before anything else. Function waits now
	// rather than immediately prior to executing request to conserve resources
	// in more intensive applications.
	c.limiter.Connect()
	defer c.limiter.Disconnect()
	// Gain read lock (holds no importance as of yet but will in the near future)
	c.locker.RLock()
	defer c.locker.RUnlock()
	var request *http.Request
	request, err = http.NewRequest("GET", c.opts.RootAddress+path, nil)
	if err != nil {
		return
	}
	if c.opts.UserAgent != "" {
		request.Header.Add("User-Agent", c.opts.UserAgent)
	}
	request.Header.Add("Accept", CRESTVersion)

	webClient := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: c.opts.DisableTLS},
		},
	}
	var rawresp *http.Response
	rawresp, err = webClient.Do(request)
	if err != nil {
		return
	}
	defer rawresp.Body.Close()
	var body []byte
	body, err = ioutil.ReadAll(rawresp.Body)
	if err != nil {
		return fmt.Errorf("%v: %v", ErrCRESTUnmarshal, err)
	}
	// Check if there's an error in the response.
	err = responseError(rawresp, body)
	if err != nil {
		return
	}
	err = json.Unmarshal(body, &model)
	return err
}
